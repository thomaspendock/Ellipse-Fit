import tkinter
from math import sqrt, pi, cos, sin
from graphics.Graphics import GUI, dist

gui = GUI(width=800, height=800, point_radius=10, num_points=30)


def motion(event):
    '''If the mouse cursor is down, animate the changing dynamic circle.''''
    # Do nothing if the user is not pressing the mouse or the the mouse
    # is out of bounds
    if gui.x_mouse_click == -1 or \
       gui.y_mouse_click == -1 or \
       not gui.mouse_down: return

    # Radius of the circle is the distance between the original click
    # and the current position of the mouse.
    radius = dist((gui.x_mouse_click, event.x),
                  (gui.y_mouse_click, event.y))

    # Circle is too small to draw
    if radius < 1: return

    # Delete the existing circle and create a updated one with updated size.
    if gui.dynamic_circ != None: gui.canvas.delete(gui.dynamic_circ)
    gui.dynamic_circ = gui.draw_oval(gui.x_mouse_click, gui.y_mouse_click, radius, 'blue')

def click(event):
    '''Records the coordinates of the most recent mouse click.'''
    if gui.in_bounds(event.x, event.y):
        gui.x_mouse_click = event.x
        gui.y_mouse_click = event.y
        gui.mouse_down = True
    else:
        gui.x_mouse_click = -1
        gui.y_mouse_click = -1
        gui.mouse_down = False

def release(event):
    '''Color all the points that match the drawn circle, and draw the min and
       max red circles.'''
    gui.mouse_down = False
    if gui.x_mouse_click == -1 or gui.y_mouse_click == -1: return

    # Radius of the circle is the distance between the original click
    # and the current position of the mouse.
    radius = dist((gui.x_mouse_click, event.x),
                  (gui.y_mouse_click, event.y))

    # Circle is too small to draw
    if radius < 1: return

    # Draw the circle generated by the user
    ID = gui.draw_oval(gui.x_mouse_click, gui.y_mouse_click, radius, 'blue')
    gui.circle_ids.append(ID)

    # Keep track of the min and max distance points colored by the user circle
    min_dis = 10000
    max_dis = -1

    # Generate a range of angles around the circle and fill the closest
    # point at each angle iteration
    point_size = gui.WIDTH/gui.NUM_POINTS
    num = int(2*pi*radius / point_size)
    for t in range(0, num):
        angle = 2*t*pi/num
        x = radius*cos(angle) + gui.x_mouse_click
        y = radius*sin(angle) + gui.y_mouse_click
        i,j = gui.coord_to_index(x,y)
        
        # If the index of the closest point is in bounds
        if 0 <= i < gui.NUM_POINTS and 0 <= j < gui.NUM_POINTS:
            xp, yp = gui.index_to_coord(i,j)
            gui.color_point(xp,yp)
            distance_to_center = dist((gui.x_mouse_click, xp), (gui.y_mouse_click, yp))
            
            # Update the min and max distances
            max_dis = max(distance_to_center, max_dis)
            min_dis = min(distance_to_center, min_dis)

    # Draw the min and max radius circles
    ID = gui.draw_oval(gui.x_mouse_click, gui.y_mouse_click, min_dis, 'red')
    gui.circle_ids.append(ID)
    ID = gui.draw_oval(gui.x_mouse_click, gui.y_mouse_click, max_dis, 'red')
    gui.circle_ids.append(ID)

# Bind the user mouse and clicking events to the functions above.
gui.window.bind('<Motion>', motion)
gui.window.bind('<Button-1>', click)
gui.window.bind('<ButtonRelease-1>', release)

gui.window.mainloop() # open the window 

